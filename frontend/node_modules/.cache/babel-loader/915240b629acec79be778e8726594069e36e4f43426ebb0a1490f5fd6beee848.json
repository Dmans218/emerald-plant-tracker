{"ast":null,"code":"import Tesseract from 'tesseract.js';\n\n// Parse environmental data from Spider Farmer app screenshot\nexport const parseSpiderFarmerScreenshot = async imageFile => {\n  try {\n    const {\n      data: {\n        text\n      }\n    } = await Tesseract.recognize(imageFile, 'eng', {\n      logger: m => console.log(m),\n      tessedit_char_whitelist: '0123456789.°C%kPa ppm μmol/s-+:VPDCOTemperatureHumidity '\n    });\n    console.log('OCR Text:', text);\n\n    // Initialize result object\n    const result = {\n      temperature: null,\n      humidity: null,\n      ph: null,\n      co2: null,\n      vpd: null,\n      ppfd: null,\n      success: false,\n      parsedValues: {}\n    };\n\n    // Clean text and split into lines for better parsing\n    const lines = text.split('\\n').map(line => line.trim()).filter(line => line.length > 0);\n    const cleanText = text.replace(/\\s+/g, ' ').toLowerCase();\n\n    // More aggressive parsing for Spider Farmer layout\n    // Look for decimal numbers followed by units\n    const allNumbers = text.match(/\\d+\\.?\\d*/g) || [];\n    console.log('Found numbers:', allNumbers);\n\n    // Parse Air Temperature (°C pattern)\n    let tempMatch = text.match(/(\\d+\\.?\\d*)\\s*[°º]\\s*[cC]/i) || text.match(/temp[eratu]*[\\s:]*(\\d+\\.?\\d*)/i);\n\n    // If no direct pattern, look for numbers in typical temp range near temperature keywords\n    if (!tempMatch && allNumbers.length > 0) {\n      const tempKeywords = ['temp', 'temperature', '°', 'º'];\n      for (const num of allNumbers) {\n        const val = parseFloat(num);\n        if (val >= 15 && val <= 35) {\n          // Typical indoor growing temp range in Celsius\n          const numIndex = text.indexOf(num);\n          const surrounding = text.substring(Math.max(0, numIndex - 10), numIndex + 20).toLowerCase();\n          if (tempKeywords.some(keyword => surrounding.includes(keyword))) {\n            tempMatch = [null, num];\n            break;\n          }\n        }\n      }\n    }\n    if (tempMatch) {\n      result.temperature = parseFloat(tempMatch[1]);\n      result.parsedValues.temperature = `${tempMatch[1]}°C`;\n    }\n\n    // Parse Humidity (% pattern)\n    let humidityMatch = text.match(/(\\d+\\.?\\d*)\\s*%/) || text.match(/humid[ity]*[\\s:]*(\\d+\\.?\\d*)/i);\n\n    // Look for numbers in humidity range\n    if (!humidityMatch && allNumbers.length > 0) {\n      for (const num of allNumbers) {\n        const val = parseFloat(num);\n        if (val >= 20 && val <= 100) {\n          // Typical humidity range\n          const numIndex = text.indexOf(num);\n          const surrounding = text.substring(Math.max(0, numIndex - 10), numIndex + 20).toLowerCase();\n          if (surrounding.includes('%') || surrounding.includes('humid')) {\n            humidityMatch = [null, num];\n            break;\n          }\n        }\n      }\n    }\n    if (humidityMatch) {\n      result.humidity = parseFloat(humidityMatch[1]);\n      result.parsedValues.humidity = `${humidityMatch[1]}%`;\n    }\n\n    // Parse VPD (kPa pattern)\n    let vpdMatch = text.match(/(\\d+\\.?\\d*)\\s*kPa/i) || text.match(/vpd[\\s:]*(\\d+\\.?\\d*)/i);\n\n    // Look for numbers in VPD range\n    if (!vpdMatch && allNumbers.length > 0) {\n      for (const num of allNumbers) {\n        const val = parseFloat(num);\n        if (val >= 0.1 && val <= 3.0) {\n          // Typical VPD range\n          const numIndex = text.indexOf(num);\n          const surrounding = text.substring(Math.max(0, numIndex - 10), numIndex + 20).toLowerCase();\n          if (surrounding.includes('vpd') || surrounding.includes('kpa')) {\n            vpdMatch = [null, num];\n            break;\n          }\n        }\n      }\n    }\n    if (vpdMatch) {\n      result.vpd = parseFloat(vpdMatch[1]);\n      result.parsedValues.vpd = `${vpdMatch[1]} kPa`;\n    }\n\n    // Parse CO2 (ppm pattern)\n    let co2Match = text.match(/co\\s*[₂2]?\\s*[:\\-]?\\s*(\\d+)/i) || text.match(/(\\d+)\\s*ppm/i);\n\n    // Look for numbers in CO2 range\n    if (!co2Match && allNumbers.length > 0) {\n      for (const num of allNumbers) {\n        const val = parseFloat(num);\n        if (val >= 300 && val <= 2000) {\n          // Typical CO2 range\n          const numIndex = text.indexOf(num);\n          const surrounding = text.substring(Math.max(0, numIndex - 15), numIndex + 15).toLowerCase();\n          if (surrounding.includes('co2') || surrounding.includes('ppm')) {\n            co2Match = [null, num];\n            break;\n          }\n        }\n      }\n    }\n    if (co2Match) {\n      result.co2 = parseFloat(co2Match[1]);\n      result.parsedValues.co2 = `${co2Match[1]} ppm`;\n    }\n\n    // Parse PPFD (μmol pattern)\n    let ppfdMatch = text.match(/ppfd\\s*[:\\-]?\\s*(\\d+)/i) || text.match(/(\\d+)\\s*[μu]mol/i);\n\n    // Look for numbers in PPFD range\n    if (!ppfdMatch && allNumbers.length > 0) {\n      for (const num of allNumbers) {\n        const val = parseFloat(num);\n        if (val >= 100 && val <= 2000) {\n          // Typical PPFD range\n          const numIndex = text.indexOf(num);\n          const surrounding = text.substring(Math.max(0, numIndex - 15), numIndex + 15).toLowerCase();\n          if (surrounding.includes('ppfd') || surrounding.includes('μmol') || surrounding.includes('umol')) {\n            ppfdMatch = [null, num];\n            break;\n          }\n        }\n      }\n    }\n    if (ppfdMatch) {\n      result.ppfd = parseFloat(ppfdMatch[1]);\n      result.parsedValues.ppfd = `${ppfdMatch[1]} μmol/m²/s`;\n    }\n\n    // Parse pH\n    let phMatch = text.match(/ph\\s*[:\\-]?\\s*(\\d+\\.?\\d*)/i);\n    if (!phMatch && allNumbers.length > 0) {\n      for (const num of allNumbers) {\n        const val = parseFloat(num);\n        if (val >= 4.0 && val <= 9.0) {\n          // Typical pH range\n          const numIndex = text.indexOf(num);\n          const surrounding = text.substring(Math.max(0, numIndex - 10), numIndex + 10).toLowerCase();\n          if (surrounding.includes('ph')) {\n            phMatch = [null, num];\n            break;\n          }\n        }\n      }\n    }\n    if (phMatch) {\n      result.ph = parseFloat(phMatch[1]);\n      result.parsedValues.ph = phMatch[1];\n    }\n\n    // Check if we found at least one value\n    result.success = Object.values(result).some(val => val !== null && typeof val === 'number');\n    console.log('Parsed result:', result);\n    return result;\n  } catch (error) {\n    console.error('OCR Error:', error);\n    return {\n      temperature: null,\n      humidity: null,\n      ph: null,\n      co2: null,\n      vpd: null,\n      ppfd: null,\n      success: false,\n      error: error.message,\n      parsedValues: {}\n    };\n  }\n};\n\n// Helper function to preprocess image for better OCR\nexport const preprocessImageForOCR = (canvas, context) => {\n  const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n  const data = imageData.data;\n\n  // Convert to grayscale and increase contrast\n  for (let i = 0; i < data.length; i += 4) {\n    const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;\n\n    // Increase contrast (simple threshold)\n    const contrast = gray > 128 ? 255 : 0;\n    data[i] = contrast; // Red\n    data[i + 1] = contrast; // Green\n    data[i + 2] = contrast; // Blue\n  }\n  context.putImageData(imageData, 0, 0);\n  return canvas.toDataURL();\n};\n\n// Parse different app layouts/formats\nexport const parseEnvironmentalData = async imageFile => {\n  // Try Spider Farmer format first\n  const spiderFarmerResult = await parseSpiderFarmerScreenshot(imageFile);\n  if (spiderFarmerResult.success) {\n    return {\n      ...spiderFarmerResult,\n      source: 'Spider Farmer App'\n    };\n  }\n\n  // Could add other app parsers here in the future\n  return {\n    ...spiderFarmerResult,\n    source: 'Unknown',\n    message: 'Could not parse environmental data from image. Please ensure the image shows clear readings from a supported app.'\n  };\n};","map":{"version":3,"names":["Tesseract","parseSpiderFarmerScreenshot","imageFile","data","text","recognize","logger","m","console","log","tessedit_char_whitelist","result","temperature","humidity","ph","co2","vpd","ppfd","success","parsedValues","lines","split","map","line","trim","filter","length","cleanText","replace","toLowerCase","allNumbers","match","tempMatch","tempKeywords","num","val","parseFloat","numIndex","indexOf","surrounding","substring","Math","max","some","keyword","includes","humidityMatch","vpdMatch","co2Match","ppfdMatch","phMatch","Object","values","error","message","preprocessImageForOCR","canvas","context","imageData","getImageData","width","height","i","gray","contrast","putImageData","toDataURL","parseEnvironmentalData","spiderFarmerResult","source"],"sources":["/home/dmans218/projects/Growlogger/frontend/src/utils/ocrParser.js"],"sourcesContent":["import Tesseract from 'tesseract.js';\n\n// Parse environmental data from Spider Farmer app screenshot\nexport const parseSpiderFarmerScreenshot = async (imageFile) => {\n  try {\n    const { data: { text } } = await Tesseract.recognize(imageFile, 'eng', {\n      logger: m => console.log(m),\n      tessedit_char_whitelist: '0123456789.°C%kPa ppm μmol/s-+:VPDCOTemperatureHumidity ',\n    });\n\n    console.log('OCR Text:', text);\n\n    // Initialize result object\n    const result = {\n      temperature: null,\n      humidity: null,\n      ph: null,\n      co2: null,\n      vpd: null,\n      ppfd: null,\n      success: false,\n      parsedValues: {}\n    };\n\n    // Clean text and split into lines for better parsing\n    const lines = text.split('\\n').map(line => line.trim()).filter(line => line.length > 0);\n    const cleanText = text.replace(/\\s+/g, ' ').toLowerCase();\n\n    // More aggressive parsing for Spider Farmer layout\n    // Look for decimal numbers followed by units\n    const allNumbers = text.match(/\\d+\\.?\\d*/g) || [];\n    console.log('Found numbers:', allNumbers);\n\n    // Parse Air Temperature (°C pattern)\n    let tempMatch = text.match(/(\\d+\\.?\\d*)\\s*[°º]\\s*[cC]/i) || \n                    text.match(/temp[eratu]*[\\s:]*(\\d+\\.?\\d*)/i);\n    \n    // If no direct pattern, look for numbers in typical temp range near temperature keywords\n    if (!tempMatch && allNumbers.length > 0) {\n      const tempKeywords = ['temp', 'temperature', '°', 'º'];\n      for (const num of allNumbers) {\n        const val = parseFloat(num);\n        if (val >= 15 && val <= 35) { // Typical indoor growing temp range in Celsius\n          const numIndex = text.indexOf(num);\n          const surrounding = text.substring(Math.max(0, numIndex - 10), numIndex + 20).toLowerCase();\n          if (tempKeywords.some(keyword => surrounding.includes(keyword))) {\n            tempMatch = [null, num];\n            break;\n          }\n        }\n      }\n    }\n    \n    if (tempMatch) {\n      result.temperature = parseFloat(tempMatch[1]);\n      result.parsedValues.temperature = `${tempMatch[1]}°C`;\n    }\n\n    // Parse Humidity (% pattern)\n    let humidityMatch = text.match(/(\\d+\\.?\\d*)\\s*%/) ||\n                        text.match(/humid[ity]*[\\s:]*(\\d+\\.?\\d*)/i);\n    \n    // Look for numbers in humidity range\n    if (!humidityMatch && allNumbers.length > 0) {\n      for (const num of allNumbers) {\n        const val = parseFloat(num);\n        if (val >= 20 && val <= 100) { // Typical humidity range\n          const numIndex = text.indexOf(num);\n          const surrounding = text.substring(Math.max(0, numIndex - 10), numIndex + 20).toLowerCase();\n          if (surrounding.includes('%') || surrounding.includes('humid')) {\n            humidityMatch = [null, num];\n            break;\n          }\n        }\n      }\n    }\n    \n    if (humidityMatch) {\n      result.humidity = parseFloat(humidityMatch[1]);\n      result.parsedValues.humidity = `${humidityMatch[1]}%`;\n    }\n\n    // Parse VPD (kPa pattern)\n    let vpdMatch = text.match(/(\\d+\\.?\\d*)\\s*kPa/i) ||\n                   text.match(/vpd[\\s:]*(\\d+\\.?\\d*)/i);\n    \n    // Look for numbers in VPD range\n    if (!vpdMatch && allNumbers.length > 0) {\n      for (const num of allNumbers) {\n        const val = parseFloat(num);\n        if (val >= 0.1 && val <= 3.0) { // Typical VPD range\n          const numIndex = text.indexOf(num);\n          const surrounding = text.substring(Math.max(0, numIndex - 10), numIndex + 20).toLowerCase();\n          if (surrounding.includes('vpd') || surrounding.includes('kpa')) {\n            vpdMatch = [null, num];\n            break;\n          }\n        }\n      }\n    }\n    \n    if (vpdMatch) {\n      result.vpd = parseFloat(vpdMatch[1]);\n      result.parsedValues.vpd = `${vpdMatch[1]} kPa`;\n    }\n\n        // Parse CO2 (ppm pattern)\n    let co2Match = text.match(/co\\s*[₂2]?\\s*[:\\-]?\\s*(\\d+)/i) || \n                     text.match(/(\\d+)\\s*ppm/i);\n    \n    // Look for numbers in CO2 range\n    if (!co2Match && allNumbers.length > 0) {\n      for (const num of allNumbers) {\n        const val = parseFloat(num);\n        if (val >= 300 && val <= 2000) { // Typical CO2 range\n          const numIndex = text.indexOf(num);\n          const surrounding = text.substring(Math.max(0, numIndex - 15), numIndex + 15).toLowerCase();\n          if (surrounding.includes('co2') || surrounding.includes('ppm')) {\n            co2Match = [null, num];\n            break;\n          }\n        }\n      }\n    }\n    \n    if (co2Match) {\n      result.co2 = parseFloat(co2Match[1]);\n      result.parsedValues.co2 = `${co2Match[1]} ppm`;\n    }\n\n        // Parse PPFD (μmol pattern)\n    let ppfdMatch = text.match(/ppfd\\s*[:\\-]?\\s*(\\d+)/i) ||\n                      text.match(/(\\d+)\\s*[μu]mol/i);\n    \n    // Look for numbers in PPFD range\n    if (!ppfdMatch && allNumbers.length > 0) {\n      for (const num of allNumbers) {\n        const val = parseFloat(num);\n        if (val >= 100 && val <= 2000) { // Typical PPFD range\n          const numIndex = text.indexOf(num);\n          const surrounding = text.substring(Math.max(0, numIndex - 15), numIndex + 15).toLowerCase();\n          if (surrounding.includes('ppfd') || surrounding.includes('μmol') || surrounding.includes('umol')) {\n            ppfdMatch = [null, num];\n            break;\n          }\n        }\n      }\n    }\n    \n    if (ppfdMatch) {\n      result.ppfd = parseFloat(ppfdMatch[1]);\n      result.parsedValues.ppfd = `${ppfdMatch[1]} μmol/m²/s`;\n    }\n\n    // Parse pH\n    let phMatch = text.match(/ph\\s*[:\\-]?\\s*(\\d+\\.?\\d*)/i);\n    if (!phMatch && allNumbers.length > 0) {\n      for (const num of allNumbers) {\n        const val = parseFloat(num);\n        if (val >= 4.0 && val <= 9.0) { // Typical pH range\n          const numIndex = text.indexOf(num);\n          const surrounding = text.substring(Math.max(0, numIndex - 10), numIndex + 10).toLowerCase();\n          if (surrounding.includes('ph')) {\n            phMatch = [null, num];\n            break;\n          }\n        }\n      }\n    }\n    \n    if (phMatch) {\n      result.ph = parseFloat(phMatch[1]);\n      result.parsedValues.ph = phMatch[1];\n    }\n\n    // Check if we found at least one value\n    result.success = Object.values(result).some(val => val !== null && typeof val === 'number');\n\n    console.log('Parsed result:', result);\n    return result;\n  } catch (error) {\n    console.error('OCR Error:', error);\n    return {\n      temperature: null,\n      humidity: null,\n      ph: null,\n      co2: null,\n      vpd: null,\n      ppfd: null,\n      success: false,\n      error: error.message,\n      parsedValues: {}\n    };\n  }\n};\n\n// Helper function to preprocess image for better OCR\nexport const preprocessImageForOCR = (canvas, context) => {\n  const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n  const data = imageData.data;\n\n  // Convert to grayscale and increase contrast\n  for (let i = 0; i < data.length; i += 4) {\n    const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;\n    \n    // Increase contrast (simple threshold)\n    const contrast = gray > 128 ? 255 : 0;\n    \n    data[i] = contrast;     // Red\n    data[i + 1] = contrast; // Green\n    data[i + 2] = contrast; // Blue\n  }\n\n  context.putImageData(imageData, 0, 0);\n  return canvas.toDataURL();\n};\n\n// Parse different app layouts/formats\nexport const parseEnvironmentalData = async (imageFile) => {\n  // Try Spider Farmer format first\n  const spiderFarmerResult = await parseSpiderFarmerScreenshot(imageFile);\n  \n  if (spiderFarmerResult.success) {\n    return {\n      ...spiderFarmerResult,\n      source: 'Spider Farmer App'\n    };\n  }\n\n  // Could add other app parsers here in the future\n  return {\n    ...spiderFarmerResult,\n    source: 'Unknown',\n    message: 'Could not parse environmental data from image. Please ensure the image shows clear readings from a supported app.'\n  };\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}