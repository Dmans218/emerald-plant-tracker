{"ast":null,"code":"import Tesseract from 'tesseract.js';\nimport EXIF from 'exif-js';\n\n// Extract EXIF data from image file\nconst getImageMetadata = file => {\n  return new Promise(resolve => {\n    EXIF.getData(file, function () {\n      const dateTime = EXIF.getTag(this, \"DateTime\") || EXIF.getTag(this, \"DateTimeOriginal\") || EXIF.getTag(this, \"DateTimeDigitized\");\n      let timestamp = null;\n      if (dateTime) {\n        // EXIF date format is \"YYYY:MM:DD HH:MM:SS\"\n        // Convert to ISO format for JavaScript Date\n        const isoDateString = dateTime.replace(/^(\\d{4}):(\\d{2}):(\\d{2})/, '$1-$2-$3');\n        timestamp = new Date(isoDateString).toISOString();\n      }\n      const make = EXIF.getTag(this, \"Make\") || \"\";\n      const model = EXIF.getTag(this, \"Model\") || \"\";\n      const camera = [make, model].filter(Boolean).join(\" \") || \"Unknown\";\n      resolve({\n        timestamp: timestamp,\n        camera: camera,\n        orientation: EXIF.getTag(this, \"Orientation\")\n      });\n    });\n  });\n};\n\n// Parse environmental data from Spider Farmer app screenshot\nexport const parseSpiderFarmerScreenshot = async imageFile => {\n  try {\n    const {\n      data: {\n        text\n      }\n    } = await Tesseract.recognize(imageFile, 'eng', {\n      logger: m => console.log(m),\n      tessedit_char_whitelist: '0123456789.°C%kPa ppm μmol/s-+:VPDCOTemperatureHumidityAir '\n    });\n    console.log('OCR Raw Text:', text);\n\n    // Initialize result object\n    const result = {\n      temperature: null,\n      humidity: null,\n      ph: null,\n      co2: null,\n      vpd: null,\n      ppfd: null,\n      success: false,\n      parsedValues: {}\n    };\n\n    // Clean text for better analysis\n    const lines = text.split('\\n').map(line => line.trim()).filter(line => line.length > 0);\n    console.log('Text lines:', lines);\n\n    // Extract all numbers with context for smarter parsing\n    const numberPattern = /(\\d+\\.?\\d*)/g;\n    const allNumbers = [];\n    let match;\n    while ((match = numberPattern.exec(text)) !== null) {\n      const number = parseFloat(match[1]);\n      const index = match.index;\n      const contextBefore = text.substring(Math.max(0, index - 20), index).toLowerCase();\n      const contextAfter = text.substring(index, Math.min(text.length, index + 20)).toLowerCase();\n      allNumbers.push({\n        value: number,\n        text: match[1],\n        index: index,\n        contextBefore: contextBefore,\n        contextAfter: contextAfter,\n        fullContext: contextBefore + match[1] + contextAfter\n      });\n    }\n    console.log('Numbers with context:', allNumbers);\n\n    // Parse Temperature - look for temperature in proper range with °C\n    for (const num of allNumbers) {\n      if (!result.temperature && num.value >= 15 && num.value <= 40) {\n        const context = num.fullContext;\n        // Check if it's near temperature indicators and has degree symbol\n        if ((context.includes('temp') || context.includes('air')) && (context.includes('°') || context.includes('º')) && !context.includes('vpd') && !context.includes('%')) {\n          result.temperature = num.value;\n          result.parsedValues.temperature = `${num.value}°C`;\n          console.log('Found temperature:', num.value, 'Context:', context);\n          break;\n        }\n      }\n    }\n\n    // Parse Humidity - look for values that appear after \"Air Humi\" or \"Humi\" keywords\n    for (const num of allNumbers) {\n      if (!result.humidity && num.value >= 20 && num.value <= 100) {\n        const context = num.fullContext;\n        const beforeText = num.contextBefore;\n        const afterText = num.contextAfter;\n\n        // Check if this number appears after humidity keywords\n        const afterHumidityLabel = beforeText.includes('humi') || beforeText.includes('humid');\n        const notTemperature = !context.includes('°') && !context.includes('temp');\n        const notVPD = !context.includes('vpd') && !context.includes('kpa');\n        const notInHeader = !beforeText.includes('mm') && !beforeText.includes('c&c') && !beforeText.includes('®');\n\n        // Prioritize numbers that come after humidity labels\n        if (afterHumidityLabel && notTemperature && notVPD && notInHeader) {\n          result.humidity = num.value;\n          result.parsedValues.humidity = `${num.value}%`;\n          console.log('Found humidity after label:', num.value, 'Context:', context);\n          break;\n        }\n      }\n    }\n\n    // Fallback: look for numbers in a data row structure (like \"21.7 < 78.1 0.57\")\n    if (!result.humidity) {\n      for (const num of allNumbers) {\n        if (num.value >= 50 && num.value <= 100) {\n          const context = num.fullContext;\n          const beforeText = num.contextBefore;\n          const afterText = num.contextAfter;\n\n          // Look for numbers in a sequence that could be temp, humidity, vpd\n          const inDataRow = (beforeText.includes('21') || beforeText.includes('22') || beforeText.includes('20')) && (afterText.includes('0.') || context.includes('<'));\n          const notInHeader = !beforeText.includes('mm') && !beforeText.includes('®') && !beforeText.includes('¢');\n          if (inDataRow && notInHeader) {\n            result.humidity = num.value;\n            result.parsedValues.humidity = `${num.value}%`;\n            console.log('Found humidity in data row:', num.value, 'Context:', context);\n            break;\n          }\n        }\n      }\n    }\n\n    // Parse VPD - look for small decimal values with kPa context  \n    for (const num of allNumbers) {\n      if (!result.vpd && num.value >= 0.1 && num.value <= 5.0) {\n        const context = num.fullContext;\n        // VPD should be small decimal near \"VPD\" text or \"kPa\"\n        if (context.includes('vpd') || context.includes('kpa') && num.value < 10 || num.value < 2.0 && context.includes('kpa')) {\n          result.vpd = num.value;\n          result.parsedValues.vpd = `${num.value} kPa`;\n          console.log('Found VPD:', num.value, 'Context:', context);\n          break;\n        }\n      }\n    }\n\n    // Fallback parsing if direct context matching fails\n    if (!result.temperature || !result.humidity || !result.vpd) {\n      console.log('Using fallback parsing...');\n\n      // Sort numbers by value to help identify them\n      const sortedNumbers = [...allNumbers].sort((a, b) => a.value - b.value);\n      console.log('Sorted numbers:', sortedNumbers.map(n => n.value));\n\n      // If we don't have temperature, look for number around 20-25 (room temp)\n      if (!result.temperature) {\n        const tempCandidate = sortedNumbers.find(n => n.value >= 18 && n.value <= 30);\n        if (tempCandidate && !tempCandidate.fullContext.includes('%')) {\n          result.temperature = tempCandidate.value;\n          result.parsedValues.temperature = `${tempCandidate.value}°C`;\n          console.log('Fallback temperature:', tempCandidate.value);\n        }\n      }\n\n      // If we don't have humidity, look for numbers with % symbol, prioritizing higher values\n      if (!result.humidity) {\n        // First try to find numbers with % that are in typical humidity range (50-90%)\n        const humidCandidate = sortedNumbers.reverse().find(n => n.value >= 50 && n.value <= 100 && n.fullContext.includes('%') && !n.fullContext.includes('°') && !n.fullContext.includes('vpd') && !n.fullContext.includes('kpa'));\n\n        // If not found, try broader range (30-100%)\n        const humidCandidate2 = humidCandidate || sortedNumbers.find(n => n.value >= 30 && n.value <= 100 && n.fullContext.includes('%') && !n.fullContext.includes('°'));\n        if (humidCandidate || humidCandidate2) {\n          const candidate = humidCandidate || humidCandidate2;\n          result.humidity = candidate.value;\n          result.parsedValues.humidity = `${candidate.value}%`;\n          console.log('Fallback humidity:', candidate.value, 'Context:', candidate.fullContext);\n        }\n      }\n\n      // If we don't have VPD, look for small decimals\n      if (!result.vpd) {\n        const vpdCandidate = sortedNumbers.find(n => n.value >= 0.1 && n.value <= 2.0 && n.text.includes('.'));\n        if (vpdCandidate) {\n          result.vpd = vpdCandidate.value;\n          result.parsedValues.vpd = `${vpdCandidate.value} kPa`;\n          console.log('Fallback VPD:', vpdCandidate.value);\n        }\n      }\n    }\n\n    // Parse CO2 (ppm pattern)\n    let co2Match = text.match(/co\\s*[₂2]?\\s*[:-]?\\s*(\\d+)/i) || text.match(/(\\d+)\\s*ppm/i);\n\n    // Look for numbers in CO2 range\n    if (!co2Match && allNumbers.length > 0) {\n      for (const num of allNumbers) {\n        const val = parseFloat(num);\n        if (val >= 300 && val <= 2000) {\n          // Typical CO2 range\n          const numIndex = text.indexOf(num);\n          const surrounding = text.substring(Math.max(0, numIndex - 15), numIndex + 15).toLowerCase();\n          if (surrounding.includes('co2') || surrounding.includes('ppm')) {\n            co2Match = [null, num];\n            break;\n          }\n        }\n      }\n    }\n    if (co2Match) {\n      result.co2 = parseFloat(co2Match[1]);\n      result.parsedValues.co2 = `${co2Match[1]} ppm`;\n    }\n\n    // Parse PPFD (μmol pattern)\n    let ppfdMatch = text.match(/ppfd\\s*[:-]?\\s*(\\d+)/i) || text.match(/(\\d+)\\s*[μu]mol/i);\n\n    // Look for numbers in PPFD range\n    if (!ppfdMatch && allNumbers.length > 0) {\n      for (const num of allNumbers) {\n        const val = parseFloat(num);\n        if (val >= 100 && val <= 2000) {\n          // Typical PPFD range\n          const numIndex = text.indexOf(num);\n          const surrounding = text.substring(Math.max(0, numIndex - 15), numIndex + 15).toLowerCase();\n          if (surrounding.includes('ppfd') || surrounding.includes('μmol') || surrounding.includes('umol')) {\n            ppfdMatch = [null, num];\n            break;\n          }\n        }\n      }\n    }\n    if (ppfdMatch) {\n      result.ppfd = parseFloat(ppfdMatch[1]);\n      result.parsedValues.ppfd = `${ppfdMatch[1]} μmol/m²/s`;\n    }\n\n    // Parse pH\n    let phMatch = text.match(/ph\\s*[:-]?\\s*(\\d+\\.?\\d*)/i);\n    if (!phMatch && allNumbers.length > 0) {\n      for (const num of allNumbers) {\n        const val = parseFloat(num);\n        if (val >= 4.0 && val <= 9.0) {\n          // Typical pH range\n          const numIndex = text.indexOf(num);\n          const surrounding = text.substring(Math.max(0, numIndex - 10), numIndex + 10).toLowerCase();\n          if (surrounding.includes('ph')) {\n            phMatch = [null, num];\n            break;\n          }\n        }\n      }\n    }\n    if (phMatch) {\n      result.ph = parseFloat(phMatch[1]);\n      result.parsedValues.ph = phMatch[1];\n    }\n\n    // Check if we found at least one value\n    result.success = Object.values(result).some(val => val !== null && typeof val === 'number');\n    console.log('Parsed result:', result);\n    return result;\n  } catch (error) {\n    console.error('OCR Error:', error);\n    return {\n      temperature: null,\n      humidity: null,\n      ph: null,\n      co2: null,\n      vpd: null,\n      ppfd: null,\n      success: false,\n      error: error.message,\n      parsedValues: {}\n    };\n  }\n};\n\n// Helper function to preprocess image for better OCR\nexport const preprocessImageForOCR = (canvas, context) => {\n  const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n  const data = imageData.data;\n\n  // Convert to grayscale and increase contrast\n  for (let i = 0; i < data.length; i += 4) {\n    const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;\n\n    // Increase contrast (simple threshold)\n    const contrast = gray > 128 ? 255 : 0;\n    data[i] = contrast; // Red\n    data[i + 1] = contrast; // Green\n    data[i + 2] = contrast; // Blue\n  }\n  context.putImageData(imageData, 0, 0);\n  return canvas.toDataURL();\n};\n\n// Parse different app layouts/formats\nexport const parseEnvironmentalData = async imageFile => {\n  try {\n    // Extract image metadata (including timestamp) first\n    const metadata = await getImageMetadata(imageFile);\n    console.log('Image metadata:', metadata);\n\n    // Try Spider Farmer format first\n    const spiderFarmerResult = await parseSpiderFarmerScreenshot(imageFile);\n    if (spiderFarmerResult.success) {\n      return {\n        ...spiderFarmerResult,\n        source: 'Spider Farmer App',\n        metadata: metadata,\n        timestamp: metadata.timestamp\n      };\n    }\n\n    // Could add other app parsers here in the future\n    return {\n      ...spiderFarmerResult,\n      source: 'Unknown',\n      metadata: metadata,\n      timestamp: metadata.timestamp,\n      message: 'Could not parse environmental data from image. Please ensure the image shows clear readings from a supported app.'\n    };\n  } catch (error) {\n    console.error('Error parsing image:', error);\n    return {\n      temperature: null,\n      humidity: null,\n      ph: null,\n      co2: null,\n      vpd: null,\n      ppfd: null,\n      success: false,\n      error: error.message,\n      parsedValues: {},\n      metadata: null,\n      timestamp: null\n    };\n  }\n};","map":{"version":3,"names":["Tesseract","EXIF","getImageMetadata","file","Promise","resolve","getData","dateTime","getTag","timestamp","isoDateString","replace","Date","toISOString","make","model","camera","filter","Boolean","join","orientation","parseSpiderFarmerScreenshot","imageFile","data","text","recognize","logger","m","console","log","tessedit_char_whitelist","result","temperature","humidity","ph","co2","vpd","ppfd","success","parsedValues","lines","split","map","line","trim","length","numberPattern","allNumbers","match","exec","number","parseFloat","index","contextBefore","substring","Math","max","toLowerCase","contextAfter","min","push","value","fullContext","num","context","includes","beforeText","afterText","afterHumidityLabel","notTemperature","notVPD","notInHeader","inDataRow","sortedNumbers","sort","a","b","n","tempCandidate","find","humidCandidate","reverse","humidCandidate2","candidate","vpdCandidate","co2Match","val","numIndex","indexOf","surrounding","ppfdMatch","phMatch","Object","values","some","error","message","preprocessImageForOCR","canvas","imageData","getImageData","width","height","i","gray","contrast","putImageData","toDataURL","parseEnvironmentalData","metadata","spiderFarmerResult","source"],"sources":["/home/dmans218/projects/Growlogger/frontend/src/utils/ocrParser.js"],"sourcesContent":["import Tesseract from 'tesseract.js';\nimport EXIF from 'exif-js';\n\n// Extract EXIF data from image file\nconst getImageMetadata = (file) => {\n  return new Promise((resolve) => {\n    EXIF.getData(file, function() {\n      const dateTime = EXIF.getTag(this, \"DateTime\") || \n                      EXIF.getTag(this, \"DateTimeOriginal\") || \n                      EXIF.getTag(this, \"DateTimeDigitized\");\n      \n      let timestamp = null;\n      \n      if (dateTime) {\n        // EXIF date format is \"YYYY:MM:DD HH:MM:SS\"\n        // Convert to ISO format for JavaScript Date\n        const isoDateString = dateTime.replace(/^(\\d{4}):(\\d{2}):(\\d{2})/, '$1-$2-$3');\n        timestamp = new Date(isoDateString).toISOString();\n      }\n      \n      const make = EXIF.getTag(this, \"Make\") || \"\";\n      const model = EXIF.getTag(this, \"Model\") || \"\";\n      const camera = [make, model].filter(Boolean).join(\" \") || \"Unknown\";\n      \n      resolve({\n        timestamp: timestamp,\n        camera: camera,\n        orientation: EXIF.getTag(this, \"Orientation\")\n      });\n    });\n  });\n};\n\n// Parse environmental data from Spider Farmer app screenshot\nexport const parseSpiderFarmerScreenshot = async (imageFile) => {\n  try {\n    const { data: { text } } = await Tesseract.recognize(imageFile, 'eng', {\n      logger: m => console.log(m),\n      tessedit_char_whitelist: '0123456789.°C%kPa ppm μmol/s-+:VPDCOTemperatureHumidityAir ',\n    });\n\n    console.log('OCR Raw Text:', text);\n\n    // Initialize result object\n    const result = {\n      temperature: null,\n      humidity: null,\n      ph: null,\n      co2: null,\n      vpd: null,\n      ppfd: null,\n      success: false,\n      parsedValues: {}\n    };\n\n    // Clean text for better analysis\n    const lines = text.split('\\n').map(line => line.trim()).filter(line => line.length > 0);\n    console.log('Text lines:', lines);\n\n    // Extract all numbers with context for smarter parsing\n    const numberPattern = /(\\d+\\.?\\d*)/g;\n    const allNumbers = [];\n    let match;\n    while ((match = numberPattern.exec(text)) !== null) {\n      const number = parseFloat(match[1]);\n      const index = match.index;\n      const contextBefore = text.substring(Math.max(0, index - 20), index).toLowerCase();\n      const contextAfter = text.substring(index, Math.min(text.length, index + 20)).toLowerCase();\n      allNumbers.push({\n        value: number,\n        text: match[1],\n        index: index,\n        contextBefore: contextBefore,\n        contextAfter: contextAfter,\n        fullContext: contextBefore + match[1] + contextAfter\n      });\n    }\n    \n    console.log('Numbers with context:', allNumbers);\n\n    // Parse Temperature - look for temperature in proper range with °C\n    for (const num of allNumbers) {\n      if (!result.temperature && num.value >= 15 && num.value <= 40) {\n        const context = num.fullContext;\n        // Check if it's near temperature indicators and has degree symbol\n        if ((context.includes('temp') || context.includes('air')) && \n            (context.includes('°') || context.includes('º')) &&\n            !context.includes('vpd') && !context.includes('%')) {\n          result.temperature = num.value;\n          result.parsedValues.temperature = `${num.value}°C`;\n          console.log('Found temperature:', num.value, 'Context:', context);\n          break;\n        }\n      }\n    }\n\n    // Parse Humidity - look for values that appear after \"Air Humi\" or \"Humi\" keywords\n    for (const num of allNumbers) {\n      if (!result.humidity && num.value >= 20 && num.value <= 100) {\n        const context = num.fullContext;\n        const beforeText = num.contextBefore;\n        const afterText = num.contextAfter;\n        \n        // Check if this number appears after humidity keywords\n        const afterHumidityLabel = beforeText.includes('humi') || beforeText.includes('humid');\n        const notTemperature = !context.includes('°') && !context.includes('temp');\n        const notVPD = !context.includes('vpd') && !context.includes('kpa');\n        const notInHeader = !beforeText.includes('mm') && !beforeText.includes('c&c') && !beforeText.includes('®');\n        \n        // Prioritize numbers that come after humidity labels\n        if (afterHumidityLabel && notTemperature && notVPD && notInHeader) {\n          result.humidity = num.value;\n          result.parsedValues.humidity = `${num.value}%`;\n          console.log('Found humidity after label:', num.value, 'Context:', context);\n          break;\n        }\n      }\n    }\n    \n    // Fallback: look for numbers in a data row structure (like \"21.7 < 78.1 0.57\")\n    if (!result.humidity) {\n      for (const num of allNumbers) {\n        if (num.value >= 50 && num.value <= 100) {\n          const context = num.fullContext;\n          const beforeText = num.contextBefore;\n          const afterText = num.contextAfter;\n          \n          // Look for numbers in a sequence that could be temp, humidity, vpd\n          const inDataRow = (beforeText.includes('21') || beforeText.includes('22') || beforeText.includes('20')) && \n                           (afterText.includes('0.') || context.includes('<'));\n          const notInHeader = !beforeText.includes('mm') && !beforeText.includes('®') && !beforeText.includes('¢');\n          \n          if (inDataRow && notInHeader) {\n            result.humidity = num.value;\n            result.parsedValues.humidity = `${num.value}%`;\n            console.log('Found humidity in data row:', num.value, 'Context:', context);\n            break;\n          }\n        }\n      }\n    }\n\n    // Parse VPD - look for small decimal values with kPa context  \n    for (const num of allNumbers) {\n      if (!result.vpd && num.value >= 0.1 && num.value <= 5.0) {\n        const context = num.fullContext;\n        // VPD should be small decimal near \"VPD\" text or \"kPa\"\n        if (context.includes('vpd') || \n            (context.includes('kpa') && num.value < 10) ||\n            (num.value < 2.0 && context.includes('kpa'))) {\n          result.vpd = num.value;\n          result.parsedValues.vpd = `${num.value} kPa`;\n          console.log('Found VPD:', num.value, 'Context:', context);\n          break;\n        }\n      }\n    }\n\n    // Fallback parsing if direct context matching fails\n    if (!result.temperature || !result.humidity || !result.vpd) {\n      console.log('Using fallback parsing...');\n      \n      // Sort numbers by value to help identify them\n      const sortedNumbers = [...allNumbers].sort((a, b) => a.value - b.value);\n      console.log('Sorted numbers:', sortedNumbers.map(n => n.value));\n      \n      // If we don't have temperature, look for number around 20-25 (room temp)\n      if (!result.temperature) {\n        const tempCandidate = sortedNumbers.find(n => n.value >= 18 && n.value <= 30);\n        if (tempCandidate && !tempCandidate.fullContext.includes('%')) {\n          result.temperature = tempCandidate.value;\n          result.parsedValues.temperature = `${tempCandidate.value}°C`;\n          console.log('Fallback temperature:', tempCandidate.value);\n        }\n      }\n      \n             // If we don't have humidity, look for numbers with % symbol, prioritizing higher values\n       if (!result.humidity) {\n         // First try to find numbers with % that are in typical humidity range (50-90%)\n         const humidCandidate = sortedNumbers.reverse().find(n => \n           n.value >= 50 && n.value <= 100 && \n           n.fullContext.includes('%') &&\n           !n.fullContext.includes('°') &&\n           !n.fullContext.includes('vpd') &&\n           !n.fullContext.includes('kpa')\n         );\n         \n         // If not found, try broader range (30-100%)\n         const humidCandidate2 = humidCandidate || sortedNumbers.find(n => \n           n.value >= 30 && n.value <= 100 && \n           n.fullContext.includes('%') &&\n           !n.fullContext.includes('°')\n         );\n         \n         if (humidCandidate || humidCandidate2) {\n           const candidate = humidCandidate || humidCandidate2;\n           result.humidity = candidate.value;\n           result.parsedValues.humidity = `${candidate.value}%`;\n           console.log('Fallback humidity:', candidate.value, 'Context:', candidate.fullContext);\n         }\n       }\n      \n      // If we don't have VPD, look for small decimals\n      if (!result.vpd) {\n        const vpdCandidate = sortedNumbers.find(n => \n          n.value >= 0.1 && n.value <= 2.0 && \n          n.text.includes('.')\n        );\n        if (vpdCandidate) {\n          result.vpd = vpdCandidate.value;\n          result.parsedValues.vpd = `${vpdCandidate.value} kPa`;\n          console.log('Fallback VPD:', vpdCandidate.value);\n        }\n      }\n    }\n\n        // Parse CO2 (ppm pattern)\n    let co2Match = text.match(/co\\s*[₂2]?\\s*[:-]?\\s*(\\d+)/i) || \n                     text.match(/(\\d+)\\s*ppm/i);\n    \n    // Look for numbers in CO2 range\n    if (!co2Match && allNumbers.length > 0) {\n      for (const num of allNumbers) {\n        const val = parseFloat(num);\n        if (val >= 300 && val <= 2000) { // Typical CO2 range\n          const numIndex = text.indexOf(num);\n          const surrounding = text.substring(Math.max(0, numIndex - 15), numIndex + 15).toLowerCase();\n          if (surrounding.includes('co2') || surrounding.includes('ppm')) {\n            co2Match = [null, num];\n            break;\n          }\n        }\n      }\n    }\n    \n    if (co2Match) {\n      result.co2 = parseFloat(co2Match[1]);\n      result.parsedValues.co2 = `${co2Match[1]} ppm`;\n    }\n\n        // Parse PPFD (μmol pattern)\n    let ppfdMatch = text.match(/ppfd\\s*[:-]?\\s*(\\d+)/i) ||\n                      text.match(/(\\d+)\\s*[μu]mol/i);\n    \n    // Look for numbers in PPFD range\n    if (!ppfdMatch && allNumbers.length > 0) {\n      for (const num of allNumbers) {\n        const val = parseFloat(num);\n        if (val >= 100 && val <= 2000) { // Typical PPFD range\n          const numIndex = text.indexOf(num);\n          const surrounding = text.substring(Math.max(0, numIndex - 15), numIndex + 15).toLowerCase();\n          if (surrounding.includes('ppfd') || surrounding.includes('μmol') || surrounding.includes('umol')) {\n            ppfdMatch = [null, num];\n            break;\n          }\n        }\n      }\n    }\n    \n    if (ppfdMatch) {\n      result.ppfd = parseFloat(ppfdMatch[1]);\n      result.parsedValues.ppfd = `${ppfdMatch[1]} μmol/m²/s`;\n    }\n\n    // Parse pH\n    let phMatch = text.match(/ph\\s*[:-]?\\s*(\\d+\\.?\\d*)/i);\n    if (!phMatch && allNumbers.length > 0) {\n      for (const num of allNumbers) {\n        const val = parseFloat(num);\n        if (val >= 4.0 && val <= 9.0) { // Typical pH range\n          const numIndex = text.indexOf(num);\n          const surrounding = text.substring(Math.max(0, numIndex - 10), numIndex + 10).toLowerCase();\n          if (surrounding.includes('ph')) {\n            phMatch = [null, num];\n            break;\n          }\n        }\n      }\n    }\n    \n    if (phMatch) {\n      result.ph = parseFloat(phMatch[1]);\n      result.parsedValues.ph = phMatch[1];\n    }\n\n    // Check if we found at least one value\n    result.success = Object.values(result).some(val => val !== null && typeof val === 'number');\n\n    console.log('Parsed result:', result);\n    return result;\n  } catch (error) {\n    console.error('OCR Error:', error);\n    return {\n      temperature: null,\n      humidity: null,\n      ph: null,\n      co2: null,\n      vpd: null,\n      ppfd: null,\n      success: false,\n      error: error.message,\n      parsedValues: {}\n    };\n  }\n};\n\n// Helper function to preprocess image for better OCR\nexport const preprocessImageForOCR = (canvas, context) => {\n  const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n  const data = imageData.data;\n\n  // Convert to grayscale and increase contrast\n  for (let i = 0; i < data.length; i += 4) {\n    const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;\n    \n    // Increase contrast (simple threshold)\n    const contrast = gray > 128 ? 255 : 0;\n    \n    data[i] = contrast;     // Red\n    data[i + 1] = contrast; // Green\n    data[i + 2] = contrast; // Blue\n  }\n\n  context.putImageData(imageData, 0, 0);\n  return canvas.toDataURL();\n};\n\n// Parse different app layouts/formats\nexport const parseEnvironmentalData = async (imageFile) => {\n  try {\n    // Extract image metadata (including timestamp) first\n    const metadata = await getImageMetadata(imageFile);\n    console.log('Image metadata:', metadata);\n    \n    // Try Spider Farmer format first\n    const spiderFarmerResult = await parseSpiderFarmerScreenshot(imageFile);\n    \n    if (spiderFarmerResult.success) {\n      return {\n        ...spiderFarmerResult,\n        source: 'Spider Farmer App',\n        metadata: metadata,\n        timestamp: metadata.timestamp\n      };\n    }\n\n    // Could add other app parsers here in the future\n    return {\n      ...spiderFarmerResult,\n      source: 'Unknown',\n      metadata: metadata,\n      timestamp: metadata.timestamp,\n      message: 'Could not parse environmental data from image. Please ensure the image shows clear readings from a supported app.'\n    };\n  } catch (error) {\n    console.error('Error parsing image:', error);\n    return {\n      temperature: null,\n      humidity: null,\n      ph: null,\n      co2: null,\n      vpd: null,\n      ppfd: null,\n      success: false,\n      error: error.message,\n      parsedValues: {},\n      metadata: null,\n      timestamp: null\n    };\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}