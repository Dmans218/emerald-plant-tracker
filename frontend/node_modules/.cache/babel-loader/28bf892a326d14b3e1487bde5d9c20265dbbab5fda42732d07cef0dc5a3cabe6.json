{"ast":null,"code":"import Tesseract from 'tesseract.js';\nimport EXIF from 'exif-js';\n\n// Extract EXIF data from image file\nconst getImageMetadata = file => {\n  return new Promise(resolve => {\n    EXIF.getData(file, function () {\n      const dateTime = EXIF.getTag(this, \"DateTime\") || EXIF.getTag(this, \"DateTimeOriginal\") || EXIF.getTag(this, \"DateTimeDigitized\");\n      let timestamp = null;\n      if (dateTime) {\n        // EXIF date format is \"YYYY:MM:DD HH:MM:SS\"\n        // Convert to ISO format for JavaScript Date\n        const isoDateString = dateTime.replace(/^(\\d{4}):(\\d{2}):(\\d{2})/, '$1-$2-$3');\n        timestamp = new Date(isoDateString).toISOString();\n      }\n      resolve({\n        timestamp: timestamp,\n        camera: EXIF.getTag(this, \"Make\") + \" \" + EXIF.getTag(this, \"Model\"),\n        orientation: EXIF.getTag(this, \"Orientation\")\n      });\n    });\n  });\n};\n\n// Parse environmental data from Spider Farmer app screenshot\nexport const parseSpiderFarmerScreenshot = async imageFile => {\n  try {\n    const {\n      data: {\n        text\n      }\n    } = await Tesseract.recognize(imageFile, 'eng', {\n      logger: m => console.log(m),\n      tessedit_char_whitelist: '0123456789.°C%kPa ppm μmol/s-+:VPDCOTemperatureHumidityAir '\n    });\n    console.log('OCR Raw Text:', text);\n\n    // Initialize result object\n    const result = {\n      temperature: null,\n      humidity: null,\n      ph: null,\n      co2: null,\n      vpd: null,\n      ppfd: null,\n      success: false,\n      parsedValues: {}\n    };\n\n    // Clean text for better analysis\n    const lines = text.split('\\n').map(line => line.trim()).filter(line => line.length > 0);\n    console.log('Text lines:', lines);\n\n    // Extract all numbers with context for smarter parsing\n    const numberPattern = /(\\d+\\.?\\d*)/g;\n    const allNumbers = [];\n    let match;\n    while ((match = numberPattern.exec(text)) !== null) {\n      const number = parseFloat(match[1]);\n      const index = match.index;\n      const contextBefore = text.substring(Math.max(0, index - 20), index).toLowerCase();\n      const contextAfter = text.substring(index, Math.min(text.length, index + 20)).toLowerCase();\n      allNumbers.push({\n        value: number,\n        text: match[1],\n        index: index,\n        contextBefore: contextBefore,\n        contextAfter: contextAfter,\n        fullContext: contextBefore + match[1] + contextAfter\n      });\n    }\n    console.log('Numbers with context:', allNumbers);\n\n    // Parse Temperature - look for temperature in proper range with °C\n    for (const num of allNumbers) {\n      if (!result.temperature && num.value >= 15 && num.value <= 40) {\n        const context = num.fullContext;\n        // Check if it's near temperature indicators and has degree symbol\n        if ((context.includes('temp') || context.includes('air')) && (context.includes('°') || context.includes('º')) && !context.includes('vpd') && !context.includes('%')) {\n          result.temperature = num.value;\n          result.parsedValues.temperature = `${num.value}°C`;\n          console.log('Found temperature:', num.value, 'Context:', context);\n          break;\n        }\n      }\n    }\n\n    // Parse Humidity - look for values that appear after \"Air Humi\" or \"Humi\" keywords\n    for (const num of allNumbers) {\n      if (!result.humidity && num.value >= 20 && num.value <= 100) {\n        const context = num.fullContext;\n        const beforeText = num.contextBefore;\n        const afterText = num.contextAfter;\n\n        // Check if this number appears after humidity keywords\n        const afterHumidityLabel = beforeText.includes('humi') || beforeText.includes('humid');\n        const notTemperature = !context.includes('°') && !context.includes('temp');\n        const notVPD = !context.includes('vpd') && !context.includes('kpa');\n        const notInHeader = !beforeText.includes('mm') && !beforeText.includes('c&c') && !beforeText.includes('®');\n\n        // Prioritize numbers that come after humidity labels\n        if (afterHumidityLabel && notTemperature && notVPD && notInHeader) {\n          result.humidity = num.value;\n          result.parsedValues.humidity = `${num.value}%`;\n          console.log('Found humidity after label:', num.value, 'Context:', context);\n          break;\n        }\n      }\n    }\n\n    // Fallback: look for numbers in a data row structure (like \"21.7 < 78.1 0.57\")\n    if (!result.humidity) {\n      for (const num of allNumbers) {\n        if (num.value >= 50 && num.value <= 100) {\n          const context = num.fullContext;\n          const beforeText = num.contextBefore;\n          const afterText = num.contextAfter;\n\n          // Look for numbers in a sequence that could be temp, humidity, vpd\n          const inDataRow = (beforeText.includes('21') || beforeText.includes('22') || beforeText.includes('20')) && (afterText.includes('0.') || context.includes('<'));\n          const notInHeader = !beforeText.includes('mm') && !beforeText.includes('®') && !beforeText.includes('¢');\n          if (inDataRow && notInHeader) {\n            result.humidity = num.value;\n            result.parsedValues.humidity = `${num.value}%`;\n            console.log('Found humidity in data row:', num.value, 'Context:', context);\n            break;\n          }\n        }\n      }\n    }\n\n    // Parse VPD - look for small decimal values with kPa context  \n    for (const num of allNumbers) {\n      if (!result.vpd && num.value >= 0.1 && num.value <= 5.0) {\n        const context = num.fullContext;\n        // VPD should be small decimal near \"VPD\" text or \"kPa\"\n        if (context.includes('vpd') || context.includes('kpa') && num.value < 10 || num.value < 2.0 && context.includes('kpa')) {\n          result.vpd = num.value;\n          result.parsedValues.vpd = `${num.value} kPa`;\n          console.log('Found VPD:', num.value, 'Context:', context);\n          break;\n        }\n      }\n    }\n\n    // Fallback parsing if direct context matching fails\n    if (!result.temperature || !result.humidity || !result.vpd) {\n      console.log('Using fallback parsing...');\n\n      // Sort numbers by value to help identify them\n      const sortedNumbers = [...allNumbers].sort((a, b) => a.value - b.value);\n      console.log('Sorted numbers:', sortedNumbers.map(n => n.value));\n\n      // If we don't have temperature, look for number around 20-25 (room temp)\n      if (!result.temperature) {\n        const tempCandidate = sortedNumbers.find(n => n.value >= 18 && n.value <= 30);\n        if (tempCandidate && !tempCandidate.fullContext.includes('%')) {\n          result.temperature = tempCandidate.value;\n          result.parsedValues.temperature = `${tempCandidate.value}°C`;\n          console.log('Fallback temperature:', tempCandidate.value);\n        }\n      }\n\n      // If we don't have humidity, look for numbers with % symbol, prioritizing higher values\n      if (!result.humidity) {\n        // First try to find numbers with % that are in typical humidity range (50-90%)\n        const humidCandidate = sortedNumbers.reverse().find(n => n.value >= 50 && n.value <= 100 && n.fullContext.includes('%') && !n.fullContext.includes('°') && !n.fullContext.includes('vpd') && !n.fullContext.includes('kpa'));\n\n        // If not found, try broader range (30-100%)\n        const humidCandidate2 = humidCandidate || sortedNumbers.find(n => n.value >= 30 && n.value <= 100 && n.fullContext.includes('%') && !n.fullContext.includes('°'));\n        if (humidCandidate || humidCandidate2) {\n          const candidate = humidCandidate || humidCandidate2;\n          result.humidity = candidate.value;\n          result.parsedValues.humidity = `${candidate.value}%`;\n          console.log('Fallback humidity:', candidate.value, 'Context:', candidate.fullContext);\n        }\n      }\n\n      // If we don't have VPD, look for small decimals\n      if (!result.vpd) {\n        const vpdCandidate = sortedNumbers.find(n => n.value >= 0.1 && n.value <= 2.0 && n.text.includes('.'));\n        if (vpdCandidate) {\n          result.vpd = vpdCandidate.value;\n          result.parsedValues.vpd = `${vpdCandidate.value} kPa`;\n          console.log('Fallback VPD:', vpdCandidate.value);\n        }\n      }\n    }\n\n    // Parse CO2 (ppm pattern)\n    let co2Match = text.match(/co\\s*[₂2]?\\s*[:-]?\\s*(\\d+)/i) || text.match(/(\\d+)\\s*ppm/i);\n\n    // Look for numbers in CO2 range\n    if (!co2Match && allNumbers.length > 0) {\n      for (const num of allNumbers) {\n        const val = parseFloat(num);\n        if (val >= 300 && val <= 2000) {\n          // Typical CO2 range\n          const numIndex = text.indexOf(num);\n          const surrounding = text.substring(Math.max(0, numIndex - 15), numIndex + 15).toLowerCase();\n          if (surrounding.includes('co2') || surrounding.includes('ppm')) {\n            co2Match = [null, num];\n            break;\n          }\n        }\n      }\n    }\n    if (co2Match) {\n      result.co2 = parseFloat(co2Match[1]);\n      result.parsedValues.co2 = `${co2Match[1]} ppm`;\n    }\n\n    // Parse PPFD (μmol pattern)\n    let ppfdMatch = text.match(/ppfd\\s*[:-]?\\s*(\\d+)/i) || text.match(/(\\d+)\\s*[μu]mol/i);\n\n    // Look for numbers in PPFD range\n    if (!ppfdMatch && allNumbers.length > 0) {\n      for (const num of allNumbers) {\n        const val = parseFloat(num);\n        if (val >= 100 && val <= 2000) {\n          // Typical PPFD range\n          const numIndex = text.indexOf(num);\n          const surrounding = text.substring(Math.max(0, numIndex - 15), numIndex + 15).toLowerCase();\n          if (surrounding.includes('ppfd') || surrounding.includes('μmol') || surrounding.includes('umol')) {\n            ppfdMatch = [null, num];\n            break;\n          }\n        }\n      }\n    }\n    if (ppfdMatch) {\n      result.ppfd = parseFloat(ppfdMatch[1]);\n      result.parsedValues.ppfd = `${ppfdMatch[1]} μmol/m²/s`;\n    }\n\n    // Parse pH\n    let phMatch = text.match(/ph\\s*[:-]?\\s*(\\d+\\.?\\d*)/i);\n    if (!phMatch && allNumbers.length > 0) {\n      for (const num of allNumbers) {\n        const val = parseFloat(num);\n        if (val >= 4.0 && val <= 9.0) {\n          // Typical pH range\n          const numIndex = text.indexOf(num);\n          const surrounding = text.substring(Math.max(0, numIndex - 10), numIndex + 10).toLowerCase();\n          if (surrounding.includes('ph')) {\n            phMatch = [null, num];\n            break;\n          }\n        }\n      }\n    }\n    if (phMatch) {\n      result.ph = parseFloat(phMatch[1]);\n      result.parsedValues.ph = phMatch[1];\n    }\n\n    // Check if we found at least one value\n    result.success = Object.values(result).some(val => val !== null && typeof val === 'number');\n    console.log('Parsed result:', result);\n    return result;\n  } catch (error) {\n    console.error('OCR Error:', error);\n    return {\n      temperature: null,\n      humidity: null,\n      ph: null,\n      co2: null,\n      vpd: null,\n      ppfd: null,\n      success: false,\n      error: error.message,\n      parsedValues: {}\n    };\n  }\n};\n\n// Helper function to preprocess image for better OCR\nexport const preprocessImageForOCR = (canvas, context) => {\n  const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n  const data = imageData.data;\n\n  // Convert to grayscale and increase contrast\n  for (let i = 0; i < data.length; i += 4) {\n    const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;\n\n    // Increase contrast (simple threshold)\n    const contrast = gray > 128 ? 255 : 0;\n    data[i] = contrast; // Red\n    data[i + 1] = contrast; // Green\n    data[i + 2] = contrast; // Blue\n  }\n  context.putImageData(imageData, 0, 0);\n  return canvas.toDataURL();\n};\n\n// Parse different app layouts/formats\nexport const parseEnvironmentalData = async imageFile => {\n  try {\n    // Extract image metadata (including timestamp) first\n    const metadata = await getImageMetadata(imageFile);\n    console.log('Image metadata:', metadata);\n\n    // Try Spider Farmer format first\n    const spiderFarmerResult = await parseSpiderFarmerScreenshot(imageFile);\n    if (spiderFarmerResult.success) {\n      return {\n        ...spiderFarmerResult,\n        source: 'Spider Farmer App',\n        metadata: metadata,\n        timestamp: metadata.timestamp\n      };\n    }\n\n    // Could add other app parsers here in the future\n    return {\n      ...spiderFarmerResult,\n      source: 'Unknown',\n      metadata: metadata,\n      timestamp: metadata.timestamp,\n      message: 'Could not parse environmental data from image. Please ensure the image shows clear readings from a supported app.'\n    };\n  } catch (error) {\n    console.error('Error parsing image:', error);\n    return {\n      temperature: null,\n      humidity: null,\n      ph: null,\n      co2: null,\n      vpd: null,\n      ppfd: null,\n      success: false,\n      error: error.message,\n      parsedValues: {},\n      metadata: null,\n      timestamp: null\n    };\n  }\n};","map":{"version":3,"names":["Tesseract","EXIF","getImageMetadata","file","Promise","resolve","getData","dateTime","getTag","timestamp","isoDateString","replace","Date","toISOString","camera","orientation","parseSpiderFarmerScreenshot","imageFile","data","text","recognize","logger","m","console","log","tessedit_char_whitelist","result","temperature","humidity","ph","co2","vpd","ppfd","success","parsedValues","lines","split","map","line","trim","filter","length","numberPattern","allNumbers","match","exec","number","parseFloat","index","contextBefore","substring","Math","max","toLowerCase","contextAfter","min","push","value","fullContext","num","context","includes","beforeText","afterText","afterHumidityLabel","notTemperature","notVPD","notInHeader","inDataRow","sortedNumbers","sort","a","b","n","tempCandidate","find","humidCandidate","reverse","humidCandidate2","candidate","vpdCandidate","co2Match","val","numIndex","indexOf","surrounding","ppfdMatch","phMatch","Object","values","some","error","message","preprocessImageForOCR","canvas","imageData","getImageData","width","height","i","gray","contrast","putImageData","toDataURL","parseEnvironmentalData","metadata","spiderFarmerResult","source"],"sources":["/home/dmans218/projects/Growlogger/frontend/src/utils/ocrParser.js"],"sourcesContent":["import Tesseract from 'tesseract.js';\nimport EXIF from 'exif-js';\n\n// Extract EXIF data from image file\nconst getImageMetadata = (file) => {\n  return new Promise((resolve) => {\n    EXIF.getData(file, function() {\n      const dateTime = EXIF.getTag(this, \"DateTime\") || \n                      EXIF.getTag(this, \"DateTimeOriginal\") || \n                      EXIF.getTag(this, \"DateTimeDigitized\");\n      \n      let timestamp = null;\n      \n      if (dateTime) {\n        // EXIF date format is \"YYYY:MM:DD HH:MM:SS\"\n        // Convert to ISO format for JavaScript Date\n        const isoDateString = dateTime.replace(/^(\\d{4}):(\\d{2}):(\\d{2})/, '$1-$2-$3');\n        timestamp = new Date(isoDateString).toISOString();\n      }\n      \n      resolve({\n        timestamp: timestamp,\n        camera: EXIF.getTag(this, \"Make\") + \" \" + EXIF.getTag(this, \"Model\"),\n        orientation: EXIF.getTag(this, \"Orientation\")\n      });\n    });\n  });\n};\n\n// Parse environmental data from Spider Farmer app screenshot\nexport const parseSpiderFarmerScreenshot = async (imageFile) => {\n  try {\n    const { data: { text } } = await Tesseract.recognize(imageFile, 'eng', {\n      logger: m => console.log(m),\n      tessedit_char_whitelist: '0123456789.°C%kPa ppm μmol/s-+:VPDCOTemperatureHumidityAir ',\n    });\n\n    console.log('OCR Raw Text:', text);\n\n    // Initialize result object\n    const result = {\n      temperature: null,\n      humidity: null,\n      ph: null,\n      co2: null,\n      vpd: null,\n      ppfd: null,\n      success: false,\n      parsedValues: {}\n    };\n\n    // Clean text for better analysis\n    const lines = text.split('\\n').map(line => line.trim()).filter(line => line.length > 0);\n    console.log('Text lines:', lines);\n\n    // Extract all numbers with context for smarter parsing\n    const numberPattern = /(\\d+\\.?\\d*)/g;\n    const allNumbers = [];\n    let match;\n    while ((match = numberPattern.exec(text)) !== null) {\n      const number = parseFloat(match[1]);\n      const index = match.index;\n      const contextBefore = text.substring(Math.max(0, index - 20), index).toLowerCase();\n      const contextAfter = text.substring(index, Math.min(text.length, index + 20)).toLowerCase();\n      allNumbers.push({\n        value: number,\n        text: match[1],\n        index: index,\n        contextBefore: contextBefore,\n        contextAfter: contextAfter,\n        fullContext: contextBefore + match[1] + contextAfter\n      });\n    }\n    \n    console.log('Numbers with context:', allNumbers);\n\n    // Parse Temperature - look for temperature in proper range with °C\n    for (const num of allNumbers) {\n      if (!result.temperature && num.value >= 15 && num.value <= 40) {\n        const context = num.fullContext;\n        // Check if it's near temperature indicators and has degree symbol\n        if ((context.includes('temp') || context.includes('air')) && \n            (context.includes('°') || context.includes('º')) &&\n            !context.includes('vpd') && !context.includes('%')) {\n          result.temperature = num.value;\n          result.parsedValues.temperature = `${num.value}°C`;\n          console.log('Found temperature:', num.value, 'Context:', context);\n          break;\n        }\n      }\n    }\n\n    // Parse Humidity - look for values that appear after \"Air Humi\" or \"Humi\" keywords\n    for (const num of allNumbers) {\n      if (!result.humidity && num.value >= 20 && num.value <= 100) {\n        const context = num.fullContext;\n        const beforeText = num.contextBefore;\n        const afterText = num.contextAfter;\n        \n        // Check if this number appears after humidity keywords\n        const afterHumidityLabel = beforeText.includes('humi') || beforeText.includes('humid');\n        const notTemperature = !context.includes('°') && !context.includes('temp');\n        const notVPD = !context.includes('vpd') && !context.includes('kpa');\n        const notInHeader = !beforeText.includes('mm') && !beforeText.includes('c&c') && !beforeText.includes('®');\n        \n        // Prioritize numbers that come after humidity labels\n        if (afterHumidityLabel && notTemperature && notVPD && notInHeader) {\n          result.humidity = num.value;\n          result.parsedValues.humidity = `${num.value}%`;\n          console.log('Found humidity after label:', num.value, 'Context:', context);\n          break;\n        }\n      }\n    }\n    \n    // Fallback: look for numbers in a data row structure (like \"21.7 < 78.1 0.57\")\n    if (!result.humidity) {\n      for (const num of allNumbers) {\n        if (num.value >= 50 && num.value <= 100) {\n          const context = num.fullContext;\n          const beforeText = num.contextBefore;\n          const afterText = num.contextAfter;\n          \n          // Look for numbers in a sequence that could be temp, humidity, vpd\n          const inDataRow = (beforeText.includes('21') || beforeText.includes('22') || beforeText.includes('20')) && \n                           (afterText.includes('0.') || context.includes('<'));\n          const notInHeader = !beforeText.includes('mm') && !beforeText.includes('®') && !beforeText.includes('¢');\n          \n          if (inDataRow && notInHeader) {\n            result.humidity = num.value;\n            result.parsedValues.humidity = `${num.value}%`;\n            console.log('Found humidity in data row:', num.value, 'Context:', context);\n            break;\n          }\n        }\n      }\n    }\n\n    // Parse VPD - look for small decimal values with kPa context  \n    for (const num of allNumbers) {\n      if (!result.vpd && num.value >= 0.1 && num.value <= 5.0) {\n        const context = num.fullContext;\n        // VPD should be small decimal near \"VPD\" text or \"kPa\"\n        if (context.includes('vpd') || \n            (context.includes('kpa') && num.value < 10) ||\n            (num.value < 2.0 && context.includes('kpa'))) {\n          result.vpd = num.value;\n          result.parsedValues.vpd = `${num.value} kPa`;\n          console.log('Found VPD:', num.value, 'Context:', context);\n          break;\n        }\n      }\n    }\n\n    // Fallback parsing if direct context matching fails\n    if (!result.temperature || !result.humidity || !result.vpd) {\n      console.log('Using fallback parsing...');\n      \n      // Sort numbers by value to help identify them\n      const sortedNumbers = [...allNumbers].sort((a, b) => a.value - b.value);\n      console.log('Sorted numbers:', sortedNumbers.map(n => n.value));\n      \n      // If we don't have temperature, look for number around 20-25 (room temp)\n      if (!result.temperature) {\n        const tempCandidate = sortedNumbers.find(n => n.value >= 18 && n.value <= 30);\n        if (tempCandidate && !tempCandidate.fullContext.includes('%')) {\n          result.temperature = tempCandidate.value;\n          result.parsedValues.temperature = `${tempCandidate.value}°C`;\n          console.log('Fallback temperature:', tempCandidate.value);\n        }\n      }\n      \n             // If we don't have humidity, look for numbers with % symbol, prioritizing higher values\n       if (!result.humidity) {\n         // First try to find numbers with % that are in typical humidity range (50-90%)\n         const humidCandidate = sortedNumbers.reverse().find(n => \n           n.value >= 50 && n.value <= 100 && \n           n.fullContext.includes('%') &&\n           !n.fullContext.includes('°') &&\n           !n.fullContext.includes('vpd') &&\n           !n.fullContext.includes('kpa')\n         );\n         \n         // If not found, try broader range (30-100%)\n         const humidCandidate2 = humidCandidate || sortedNumbers.find(n => \n           n.value >= 30 && n.value <= 100 && \n           n.fullContext.includes('%') &&\n           !n.fullContext.includes('°')\n         );\n         \n         if (humidCandidate || humidCandidate2) {\n           const candidate = humidCandidate || humidCandidate2;\n           result.humidity = candidate.value;\n           result.parsedValues.humidity = `${candidate.value}%`;\n           console.log('Fallback humidity:', candidate.value, 'Context:', candidate.fullContext);\n         }\n       }\n      \n      // If we don't have VPD, look for small decimals\n      if (!result.vpd) {\n        const vpdCandidate = sortedNumbers.find(n => \n          n.value >= 0.1 && n.value <= 2.0 && \n          n.text.includes('.')\n        );\n        if (vpdCandidate) {\n          result.vpd = vpdCandidate.value;\n          result.parsedValues.vpd = `${vpdCandidate.value} kPa`;\n          console.log('Fallback VPD:', vpdCandidate.value);\n        }\n      }\n    }\n\n        // Parse CO2 (ppm pattern)\n    let co2Match = text.match(/co\\s*[₂2]?\\s*[:-]?\\s*(\\d+)/i) || \n                     text.match(/(\\d+)\\s*ppm/i);\n    \n    // Look for numbers in CO2 range\n    if (!co2Match && allNumbers.length > 0) {\n      for (const num of allNumbers) {\n        const val = parseFloat(num);\n        if (val >= 300 && val <= 2000) { // Typical CO2 range\n          const numIndex = text.indexOf(num);\n          const surrounding = text.substring(Math.max(0, numIndex - 15), numIndex + 15).toLowerCase();\n          if (surrounding.includes('co2') || surrounding.includes('ppm')) {\n            co2Match = [null, num];\n            break;\n          }\n        }\n      }\n    }\n    \n    if (co2Match) {\n      result.co2 = parseFloat(co2Match[1]);\n      result.parsedValues.co2 = `${co2Match[1]} ppm`;\n    }\n\n        // Parse PPFD (μmol pattern)\n    let ppfdMatch = text.match(/ppfd\\s*[:-]?\\s*(\\d+)/i) ||\n                      text.match(/(\\d+)\\s*[μu]mol/i);\n    \n    // Look for numbers in PPFD range\n    if (!ppfdMatch && allNumbers.length > 0) {\n      for (const num of allNumbers) {\n        const val = parseFloat(num);\n        if (val >= 100 && val <= 2000) { // Typical PPFD range\n          const numIndex = text.indexOf(num);\n          const surrounding = text.substring(Math.max(0, numIndex - 15), numIndex + 15).toLowerCase();\n          if (surrounding.includes('ppfd') || surrounding.includes('μmol') || surrounding.includes('umol')) {\n            ppfdMatch = [null, num];\n            break;\n          }\n        }\n      }\n    }\n    \n    if (ppfdMatch) {\n      result.ppfd = parseFloat(ppfdMatch[1]);\n      result.parsedValues.ppfd = `${ppfdMatch[1]} μmol/m²/s`;\n    }\n\n    // Parse pH\n    let phMatch = text.match(/ph\\s*[:-]?\\s*(\\d+\\.?\\d*)/i);\n    if (!phMatch && allNumbers.length > 0) {\n      for (const num of allNumbers) {\n        const val = parseFloat(num);\n        if (val >= 4.0 && val <= 9.0) { // Typical pH range\n          const numIndex = text.indexOf(num);\n          const surrounding = text.substring(Math.max(0, numIndex - 10), numIndex + 10).toLowerCase();\n          if (surrounding.includes('ph')) {\n            phMatch = [null, num];\n            break;\n          }\n        }\n      }\n    }\n    \n    if (phMatch) {\n      result.ph = parseFloat(phMatch[1]);\n      result.parsedValues.ph = phMatch[1];\n    }\n\n    // Check if we found at least one value\n    result.success = Object.values(result).some(val => val !== null && typeof val === 'number');\n\n    console.log('Parsed result:', result);\n    return result;\n  } catch (error) {\n    console.error('OCR Error:', error);\n    return {\n      temperature: null,\n      humidity: null,\n      ph: null,\n      co2: null,\n      vpd: null,\n      ppfd: null,\n      success: false,\n      error: error.message,\n      parsedValues: {}\n    };\n  }\n};\n\n// Helper function to preprocess image for better OCR\nexport const preprocessImageForOCR = (canvas, context) => {\n  const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n  const data = imageData.data;\n\n  // Convert to grayscale and increase contrast\n  for (let i = 0; i < data.length; i += 4) {\n    const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;\n    \n    // Increase contrast (simple threshold)\n    const contrast = gray > 128 ? 255 : 0;\n    \n    data[i] = contrast;     // Red\n    data[i + 1] = contrast; // Green\n    data[i + 2] = contrast; // Blue\n  }\n\n  context.putImageData(imageData, 0, 0);\n  return canvas.toDataURL();\n};\n\n// Parse different app layouts/formats\nexport const parseEnvironmentalData = async (imageFile) => {\n  try {\n    // Extract image metadata (including timestamp) first\n    const metadata = await getImageMetadata(imageFile);\n    console.log('Image metadata:', metadata);\n    \n    // Try Spider Farmer format first\n    const spiderFarmerResult = await parseSpiderFarmerScreenshot(imageFile);\n    \n    if (spiderFarmerResult.success) {\n      return {\n        ...spiderFarmerResult,\n        source: 'Spider Farmer App',\n        metadata: metadata,\n        timestamp: metadata.timestamp\n      };\n    }\n\n    // Could add other app parsers here in the future\n    return {\n      ...spiderFarmerResult,\n      source: 'Unknown',\n      metadata: metadata,\n      timestamp: metadata.timestamp,\n      message: 'Could not parse environmental data from image. Please ensure the image shows clear readings from a supported app.'\n    };\n  } catch (error) {\n    console.error('Error parsing image:', error);\n    return {\n      temperature: null,\n      humidity: null,\n      ph: null,\n      co2: null,\n      vpd: null,\n      ppfd: null,\n      success: false,\n      error: error.message,\n      parsedValues: {},\n      metadata: null,\n      timestamp: null\n    };\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}